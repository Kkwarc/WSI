"""
Author: Michał Kwarciński
"""
import itertools


class ExhaustingSolver:
    def __init__(self, weights, values, capacity):
        self.weights = weights
        self.values = values
        self.capacity = capacity

    def generate_all_options(self, number):
        """
        Returns all the permutations of 0 and 1 of length number
        """
        return list(itertools.product([0, 1], repeat=number))

    def find_best_option(self):
        """
        Finds the best option from all the option generated by using generate_all_options method
        """
        options = self.generate_all_options(len(self.weights))
        best_option = [[], 0, 0]
        for option in options:
            value = 0
            weight = 0
            for i in range(len(option)):
                if option[i] == 1:
                    value += self.values[i]
                    weight += self.weights[i]
            if weight <= self.capacity and value > best_option[2]:
                best_option[0] = option
                best_option[1] = weight
                best_option[2] = value
        return best_option


class HeuristicSolver:
    def __init__(self, weights, values, capacity):
        self.weights = weights
        self.values = values
        self.capacity = capacity

    def find_value_to_weight(self):
        """
        Returns list of lists containing value to weight ratio and index of given item for all the items in data
        """
        value_to_weight = []
        for i in range(len(self.weights)):
            value_to_weight.append([self.values[i] / self.weights[i], i])
        return value_to_weight

    def find_best_option(self):
        """
        Returns at least good option gotten from sorting the items by value to weight ratio
        """
        best_option = [[0 for i in range(len(self.weights))], 0, 0]
        value_to_weight = self.find_value_to_weight()
        value_to_weight.sort(reverse=True)
        for number in value_to_weight:
            if best_option[1] + self.weights[number[1]] <= self.capacity:
                best_option[0][number[1]] = 1
                best_option[1] += self.weights[number[1]]
                best_option[2] += self.values[number[1]]
            else:
                best_option[0][number[1]] = 0
        return best_option